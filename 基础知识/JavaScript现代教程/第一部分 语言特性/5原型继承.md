## 原型和继承

本章节主要介绍js是如何通过原型属性来实现继承这一特性的

1. 在js中有一个隐藏的属性[[prototype]]，它要么指向null，要么指向一个原型对象

   `__proto__`是[[prototype]]的setter和getter，而非本身对象

   *如果对象中有一个名字为prototype的属性，它就是一个普通的属性，和[[prototype]]没有关系*

2. 如何实现继承特性

   ```js
   let animal = {
     eats: true
   };
   let rabbit = {
     jumps: true,
     __proto__:animal
   };
   
   ```

   1. 当对象本身没有某个属性的时候，js就会沿着原型链查找，因此animal是可以访问到jumps和eats属性值的
   2. this的指向对象问题：当方法中出现了this，这个this指向的就是调用这个方法的对象本身，而和原型无关，无论这个方法是否来非自身的对象
   3. for...in...可以获得自身和原型链上所有的`enumerable==true`的属性和方法，而其他的获取键值的方法则只会返回本身具有的属性和方法。
   4. delete某个对象中的属性时，只会删除当前对象的属性，而不会考虑[[prototype]]。

## F.prototype

本节主要介绍当函数添加属性prototype的作用，这里需要区分，这个属性名prototype是函数的属性，而不是对象的属性名

1. F.prototype如何生效

   `F.prototype` 属性仅在 `new F` 被调用时使用，它为新对象的 `[[Prototype]]` 赋值。

   ```js
   let animal = {
     eats: true
   };
   
   function Rabbit(name) {
     this.name = name;
   }
   
   Rabbit.prototype = animal;
   
   let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal
   
   alert( rabbit.eats ); // true
   ```

   ![image-20220425164809245](C:\Users\祁馨亮.LAPTOP-M8E4TH4B\AppData\Roaming\Typora\typora-user-images\image-20220425164809245.png)

   也就是为每个对象的[[Prototype]]属性赋值，或者理解为添加了默认值，或者理解为让对象的[[Prototype]]指向它指定的对象。new完了之后，指针就会一直指向这块内存，因此这个时候该对象的[[Prototype]]不会因为F.prototype的改动而变化了。

2. F.prototype默认值

   ![image-20220502170919583](C:\Users\祁馨亮.LAPTOP-M8E4TH4B\AppData\Roaming\Typora\typora-user-images\image-20220502170919583.png)

   F.prototype其实就是一个对象，默认情况下这个对象里面仅包含一个F的构造器（在我们不在类中特意指定prototype的值的时候），利用这个特点，当我们不知道一个对象的构造函数时，仅仅知道这个对象时，我们也可以通过下面的方法创建一个类似的对象
   
   ```js
   //已知cat对象
   let cat2=new cat.construtor("miaomiao");//可以通过[[prototype]]找到这个构造器
   ```

   但是需要注意的是，如果我们对F.prototype进行改写，将原本函数的构造器覆盖了，这个方法就无法创建类似对象了。因此一般来说，我们给F.prototype添加属性，但是不会直接用新的对象将其完全覆盖。
   
   

## 原型的原型

本节解释了js中的内建对象是如何使用系统提供的方法的。我们定义的数组，函数等都可以看作是一个对象，比如`let f=new Function()`，根据上节课的理论，对象的[[prototype]]指向系统类（Array，Function，Number等）的prototype属性。函数对象本身也有prototype，但是它的prototype是它的构造器（没有出现在下图中）

<img src="C:\Users\祁馨亮.LAPTOP-M8E4TH4B\AppData\Roaming\Typora\typora-user-images\image-20220426171752099.png" alt="image-20220426171752099" style="zoom:67%;" />

- 所有的内建对象都遵循相同的模式（pattern）：
  - 方法都存储在 prototype 中（`Array.prototype`、`Object.prototype`、`Date.prototype` 等）。
  - 对象本身只存储数据（数组元素、对象属性、日期）。
- 原始数据类型也将方法存储在包装器对象的 prototype 中：`Number.prototype`、`String.prototype` 和 `Boolean.prototype`。只有 `undefined` 和 `null` 没有包装器对象。
- 内建原型可以被修改或被用新的方法填充。但是不建议更改它们。唯一允许的情况可能是，当我们添加一个还没有被 JavaScript 引擎支持，但已经被加入 JavaScript 规范的新标准时，才可能允许这样做。

## 原型方法，没有 `__proto__` 的对象

1. 当我们在创建一个对象的时候可以给它指定原型以及对象自己的属性描述器 

   ```js
   //语法：Object.create(prototype,PropertyDescriptors)
   let rabbit=Object.create(animal,{jumps{value:true}});
   ```

   从技术上来讲，我们可以在任何时候 get/set `[[Prototype]]`。但是通常我们只在创建对象的时候设置它一次，自那之后不再修改，否则会影响js的执行速度。

2. 当我们想get&set一个对象的`[[prototype]]`的时候，我们应该使用新方法`Object.getPrototypeOf(obj)`以及`Object.setPrototypeOf(obj,proto)`。而不推荐使用`__proto__`，这个属性实际上是`[[prototype]]`的getter和setter，有一种情况是用`__proto__`作为键名，就像`obj[__proto__]`，实际上即相当于取出了这个`[[prototype]]`，再用字符串给它赋值，字符串的值丢失了，因为`[[prototype]]`只接受对象或者null的赋值。

3. 我们还可以创建不带原型的方法，这种情况下，就没有上面的问题了