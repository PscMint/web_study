### Fetch

#### 发送get、post请求

```js
let response=await fetch(url,options)//发送请求，获取响应头
let result=await response.json()//将响应解析为需要的格式
```

```js
fetch(url,options).then(
	res=>res.json()
).then(obj=>/*后续处理*/)
```



1. 默认情况下是get请求
2. 如果需要设置请求的方式，某些请求头的参数，发送一些内容，以post方法发送某个对象信息为例

```js
let user = {
  name: 'John',
  surname: 'Smith'
};

let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
});

```

3. 响应头根据需要可以解析为各种格式，如text、json、arraybuffer等

#### DataForm类帮助发送表单

1. 可以直接根据HTML的表单元素创建DataForm对象
2. 使用DataForm的`append`或者`set`方法可以增加表单项

```html
<form id="formElem">
  <input type="text" name="name" value="John">
  <input type="text" name="surname" value="Smith">
  <input type="submit">
</form>

<script>
  formElem.onsubmit = async (e) => {
    e.preventDefault();

    let response = await fetch('/article/formdata/post/user', {
      method: 'POST',
      body: new FormData(formElem)
    });

    let result = await response.json();

    alert(result.message);
  };
</script>
```

#### 查看资源下载的进度

此方法只适用于下载，而不适用于上传

- 使用了定型数组，每个数组元素占一个字节，通过目前已经读取的字节数/总字节数，反映下载的进度
- 将所有的定型数组拼接

```js
// Step 1：启动 fetch，并获得一个 reader
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');

const reader = response.body.getReader();

// Step 2：获得总长度（length）
const contentLength = +response.headers.get('Content-Length');

// Step 3：读取数据
let receivedLength = 0; // 当前接收到了这么多字节
let chunks = []; // 接收到的二进制块的数组（包括 body）
while(true) {
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  chunks.push(value);
  receivedLength += value.length;

  console.log(`Received ${receivedLength} of ${contentLength}`)
}

// Step 4：将块连接到单个 Uint8Array
let chunksAll = new Uint8Array(receivedLength); // (4.1)
let position = 0;
for(let chunk of chunks) {
  chunksAll.set(chunk, position); // (4.2)
  position += chunk.length;
}

// Step 5：解码成字符串
let result = new TextDecoder("utf-8").decode(chunksAll);

// 我们完成啦！
let commits = JSON.parse(result);
alert(commits[0].author.login);
```

### 跨源请求

跨源请求需要服务器发送response带有Access-Control-Allow-Origin的属性，表示允许访问

#### 安全的跨源请求

需要满足以下的两个条件，否则视为非安全请求：

1. [安全的方法](https://fetch.spec.whatwg.org/#cors-safelisted-method)：GET，POST 或 HEAD

2. 安全的 header

    —— 仅允许自定义下列 header：

   - `Accept`，
   - `Accept-Language`，
   - `Content-Language`，
   - `Content-Type` 的值为 `application/x-www-form-urlencoded`，`multipart/form-data` 或 `text/plain`。

#### 非安全的跨源请求

需要通过一个预检请求（preflight）的过程，该请求由浏览器帮助发出，目的是获取服务器对于请求方法、源、请求头内容的许可，在进行下一步的非安全跨源请求

<img src=".\img\image-20220815151929996.png" alt="image-20220815151929996" style="zoom: 67%;" />

### url对象

url对象可以更加方便地创建和修改url

```javascript
new URL(url, [base])
```

- url可以是完整的url
- url也可以是路径，在设置了base源之后

#### url的结构

![image-20220816144618317](.\img\image-20220816144618317.png)

#### url编码

在url中可以使用的字符是有限制的，因此不能使用的字符就会进行编码，保证url可以成功发送

存在两种编码的类型：

- [encodeURI](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) —— 编码整个 URL。
- [decodeURI](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/decodeURI) —— 解码为编码前的状态。
- [encodeURIComponent](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) —— 编码 URL 组件，例如搜索参数，或者 hash，或者 pathname。
- [decodeURIComponent](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) —— 解码为编码前的状态。
- `encodeURI` 仅编码 URL 中完全禁止的字符。
- `encodeURIComponent` 也编码这类字符，此外，还编码 `#`，`$`，`&`，`+`，`,`，`/`，`:`，`;`，`=`，`?` 和 `@` 字符。

### XMLHttpRequest

#### XMLHttpRequest和fetch方法的区别

1. fetch的使用，使得XMLHttpRequest在一定程度上被废弃
2. 仍然使用XMLHttpRequest的原因：
   - 历史原因，需要兼容老的浏览器
   - 支持维护使用了XMLHttpRequest的脚本
   - XMLHttpRequest可以跟踪上传进度

#### XMLHttpRequest异步的实现方法

XMLHttpRequest使用get请求的经典代码

```JS
let xhr = new XMLHttpRequest();

xhr.open('GET', '/my/url');

xhr.send();

xhr.onload = function() {
  if (xhr.status != 200) { // HTTP error?
    // 处理 error
    alert( 'Error: ' + xhr.status);
    return;
  }

  // 获取来自 xhr.response 的响应
};

xhr.onprogress = function(event) {
  // 报告进度
  alert(`Loaded ${event.loaded} of ${event.total}`);
};

xhr.onerror = function() {
  // 处理非 HTTP error（例如网络中断）
};
```

XMLHttpRequest的对象xhr有几个常用的事件，通过监听事件来实现异步，不同于fetch使用promise

#### XMLHttpRequest的post方法

XMLHttpRequest使用post请求代码

```js
<form name="person">
  <input name="name" value="John">
  <input name="surname" value="Smith">
</form>

<script>
  // 从表单预填充 FormData
  let formData = new FormData(document.forms.person);

  // 附加一个字段
  formData.append("middle", "Lee");

  // 将其发送出去
  let xhr = new XMLHttpRequest();
  xhr.open("POST", "/article/xmlhttprequest/post/user");
  xhr.send(formData);

  xhr.onload = () => alert(xhr.response);
</script>
```

post不同于get，需要传递请求体（request-body），在send方法中设置body

### 应用场景

应用场景的很多内容，都需要配合服务器端代码，等到下一阶段学习了node.js之后可以配合再次学习

#### 长轮询

在消息很少的情况下，长轮询很有效。

如果消息比较频繁，那么上面描绘的请求-接收（requesting-receiving）消息的图表就会变成锯状状（saw-like）。

<img src=".\img\image-20220831143049649.png" alt="image-20220831143049649" style="zoom:67%;" />

每个消息都是一个单独的请求，并带有 header，身份验证开销（authentication overhead）等。

因此，在这种情况下，首选另一种方法，例如：[Websocket](https://zh.javascript.info/websocket) 或 [Server Sent Events](https://zh.javascript.info/server-sent-events)。

【实现简单的长轮询代码】

```javascript
async function subscribe() {
  let response = await fetch("/subscribe");

  if (response.status == 502) {
    // 状态 502 是连接超时错误，
    // 连接挂起时间过长时可能会发生，
    // 远程服务器或代理会关闭它
    // 让我们重新连接
    await subscribe();
  } else if (response.status != 200) {
    // 一个 error —— 让我们显示它
    showMessage(response.statusText);
    // 一秒后重新连接
    await new Promise(resolve => setTimeout(resolve, 1000));
    await subscribe();
  } else {
    // 获取并显示消息
    let message = await response.text();
    showMessage(message);
    // 再次调用 subscribe() 以获取下一条消息
    await subscribe();
  }
}

subscribe();
```

#### websocket简单入门

WebSocket 是一种在浏览器和服务器之间**建立持久连接**的现代方式。它是一种服务器和浏览器之间通讯的协议。

- WebSocket 没有跨源限制。
- 浏览器对 WebSocket 支持很好。
- 可以发送/接收字符串和二进制数据。

WebSocket 方法：

- `socket.send(data)`，
- `socket.close([code], [reason])`。

WebSocket 事件：

- `open`，
- `message`，
- `error`，
- `close`。

【浏览器端代码简单示例】

```js
let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.onopen = function(e) {
  alert("[open] Connection established");
  alert("Sending to server");
  socket.send("My name is John");
};

socket.onmessage = function(event) {
  alert(`[message] Data received from server: ${event.data}`);
};

socket.onclose = function(event) {
  if (event.wasClean) {
    alert(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
  } else {
    // 例如服务器进程被杀死或网络中断
    // 在这种情况下，event.code 通常为 1006
    alert('[close] Connection died');
  }
};

socket.onerror = function(error) {
  alert(`[error] ${error.message}`);
};
```

#### Server Sent Events简单入门

主要是应用于从服务器发送数据给浏览器端的场景，具体的使用还是结合nodejs的学习再说

![image-20220901133757658](.\img\image-20220901133757658.png)

### 网络篇知识补充和深入思考

1. 为什么fetch的请求方法无法获取load进度

2. 异步和同步的不同之处

   举例来说XMLHttpRequest发送的请求可以设置为同步的，同步的请求表示send发送请求之后，会等待所有的respond内容到达，在执行后面的语句，而异步的情况下，XMLHttpRequest的对象这可以使用load、error等事件监听下载的进度。

3. 对于跨源请求的理解
