## 原始类型的方法

javascript的7中原始类型：string number bigint boolean symbol null undefined，通过类似于java的那种为基本类型创建对象的方法，给基本类型提供了一些函数

不建议new创建基本类型，因为这样创建的变量是obj类型

除去null undefined，其他类型都有自己的方法

## 数字类型

要写有很多零的数字：

- 使用科学计数法来表示

```js
let val1=10e10 //10^10
let val2=10e-10//10^-10
```

对于不同的数字系统：

- 可以直接在十六进制（`0x`），八进制（`0o`）和二进制（`0b`）系统中写入数字。需要理解开头的符号是用来表示不同的进制类别。

- `parseInt(str，base)` 将字符串 `str` 解析为在给定的 `base` 数字系统中的整数，`2 ≤ base ≤ 36`，注意数字和进制是一致的，即str是base进制的。

  所以在parseInt()只传入一个参数的时候，一般来说就是把字符串数字(string)转换成真的数值(number)

- `num.toString(base)` 将数字转换为在给定的 `base` 数字系统中的字符串。如果使用整数常量直接调用toString会报错，因为编译器不知道小数位置的情况，所以要多加上一个点

```js
5..toString()//'5'
```



要将 `12pt` 和 `100px` 之类的值转换为数字：

- 使用 `parseInt/parseFloat` 进行“软”转换，它从字符串中读取数字，然后返回在发生 error 前可以读取到的值。

```js
//parseInt()or parseFloat()的使用，相对于Number()来说更加“智能”，可以识别非数字的一些情况
parseInt("100px")//100

//两个参数的场合，注意数字和进制是一致的
parseInt("ff",16)//ff是16进制的数字，结果是ff转化为十进制的结果255
```

小数：

- 使用 `Math.floor`，`Math.ceil`，`Math.trunc`，`Math.round` 或 `num.toFixed(precision)` 进行舍入。

  取最小的整数、取最大的整数、取最靠近的整数（正数部分四舍五入，负数部分(0-0.5]部分取大值，(0.5-1)部分取小值部分）、去掉小数部分。

- 请确保记住使用小数时会损失精度。

更多数学函数：

- 需要时请查看 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 对象。这个库很小，但是可以满足基本的需求。

  补充一个获取一定范围内的随机整数

  ```js
  Math.floor(Math.random()*(max-min+1)+min)
  ```

  

## 字符串

- 有 3 种类型的引号。

  特别的反引号``：

  - 允许字符串跨越多行
  - 使用 `${…}` 在字符串中嵌入表达式。

- JavaScript 中的字符串使用的是 UTF-16 编码。

- 我们可以使用像 `\n` 这样的特殊字符或通过使用 `\u...` 来操作它们的 Unicode 进行字符插入。记住特殊字符只是单个字符。

- 获取字符时，使用 `[]`即可。注意字符串的内容无法改变，只能开辟新的内存空间存放修改后的结果。

- 获取子字符串，使用 `slice(start,end)` 或 `substring`。slice最灵活，支持负数的索引，基本的用法是传入start和end（截取位置不包括end）

- 字符串的大/小写转换，使用：`toLowerCase/toUpperCase`。

- 查找子字符串时，使用 `indexOf`返回位置 或 `includes/startsWith/endsWith` 进行简单检查。

- 根据语言比较字符串时使用 `localeCompare`，否则将按字符代码进行比较。推荐每次比较字符串的时候就使用这个

还有其他几种有用的字符串方法：

- `str.trim()` —— 删除字符串前后的空格 (“trims”)。
- `str.repeat(n)` —— 重复字符串 `n` 次。

## 数组类型

#### 常规创建和方法

1. 创建数组的方法：

   - `let arr=[]`，这种方法比较常用，因为很简洁，我们可以直接写清楚需要创建的数组需要包括的元素

   - `let arr=new Array(length).fill(0)`，当需要创建指定大小的数组(设定默认值为0)而不清楚具体包括的元素，使用这个方法

   - `let arr=Array.of()`这个和第一种效果一样，只支持传入数组元素

   - 声明二维数组的方法：

     ```js
     let dp=new Array()
         for(let i=0;i<row;i++){
             dp.push([])
         }
     ```

     

2. 数组的存储：数组本身是一种特殊的对象，但是因为JavaScript内部有优化，不要像使用对象一样使用数组，此外数组因为和对象存储类似，不要使用==来比较数组，比较的是地址值。

3. 数组的length属性：

   - length的值=最大的下标值+1
   - length是可以写的，当length被改小之后数组也会被截去。清空数组arr.length=0;

4. 数组的存取

   从尾巴：pop、push

   从头部：shift、unshift，效率比从尾部慢

5. 循环数值

   ```js
   //不要使用for...in，会访问到很多使用不到的属性，for...in是用于对象循环访问属性和方法
   //for of 只能访问到数值，或者使用传统的for循环，可以访问到下标和值
   for(let value of arr){
   	print(value)
   }
   ```

#### 数组方法扩展

1. filter：数组中满足条件的内容会被放到新数组中，若要修改原数组就通过array

   ```js
   let results = arr.filter(function(item, index, array) {
     // 如果 true item 被 push 到 results，迭代继续
     // 如果什么都没找到，则返回空数组
   });
   //example
   const inventors_1500=inventors.filter(inventor=> inventor.year>=1500&&inventor.year<1600)
     
   ```

2. map：映射，可以给数组中的元素都执行相同的操作，之后存放到新数组中，若要修改原数组就通过array

   ```js
   let result = arr.map(function(item, index, array) {
     // 返回新值而不是当前元素
   })
   //example
   const fullNames = inventors.map(inventor => `${inventor.first} ${inventor.last}`);
       
   ```

3. sort：在js中需要添加函数辅助判断大小，sort函数会直接修改原来数组的顺序

   升序：a>b返回正数

   ```js
    inventors.sort(function(a,b){
         return a.year-b.year>0?1:-1;
       })
    console.table(inventors)
   ```

4. reduce：对数组中的数据进行迭代

   ```javascript
   let value = arr.reduce(function(accumulator, item, index, array) {
     // ...
   }, [initial]);
   //example
   const allyears=inventors.reduce((acc,inventor)=>{
         return acc+inventor.passed-inventor.year
       },0)
   ```

- `accumulator` —— 是上一个函数调用的结果，第一次等于  `initial`（如果提供了 `initial` 的话）。

- `item` —— 当前的数组元素。

- `index` —— 当前索引。

- `arr` —— 数组本身。

  *注意这个函数是需要编写返回值的*

5. some：数组中是否有项目满足条件

6. every：数组中是否所有项目都满足条件

7. find：根据条件找到数组第一个满足的项目并返回它，区别于filter返回所有

8. findIndex：根据条件找到数组第一个满足的项目并返回它在数组中的index

   条件就是一个逻辑表达式，写在箭头函数里或者在函数里返回它即可

9. indexOf、lastIndexOf：查找匹配的元素的索引值

10. splice：主要用于数组特定位置的删除和修改

    ```js
    arr.splice(start[, deleteCount, elem1, ..., elemN])
    ```

    - `start`——需要删除元素的索引位置
    - `deletCount`——从该位置开始需要删除的元素个数
    - `elem1, ..., elemN`——从该位置开始替换的新元素

## 可迭代对象

### 对于Symbol.iterator的理解

js给可迭代对象实现的一种内置的方法，帮助遍历可迭代对象中的每一个元素。使用`for...of`会自动调用可迭代对象的迭代器。

具体的原理如下：

- `obj[Symbol.iterator]()` 的结果被称为 **迭代器（iterator）**。由它处理进一步的迭代过程。
- 一个迭代器必须有 `next()` 方法，它返回一个 `{done: Boolean, value: any}` 对象，这里 `done:true` 表明迭代结束，否则 `value` 就是下一个值。

### 可迭代对象和类数组对象

【基本概念】

- 可迭代对象：实现了`obj[Symbol.iterator]()` 方法的对象
- 类数组对象：可以通过索引访问元素并且有`length`属性，但是没有实现`obj[Symbol.iterator]()` 

【可迭代对象、类数组对象->数组对象】

- Array.from()可以将类数组和可迭代对象转化为真正的数组，转换后它们可以使用数组的方法

【可迭代对象->数组对象】

- 展开运算符可以作用于任意可迭代对象，可以使用`...`将可迭代对象转化为数组


注意一般的对象应该是不符合这两类的，能够将对象的属性名和方法名遍历出来的是`for...in`

## Map和Set

### `Map` —— 是一个带键的数据项的集合。

方法和属性如下：

- `new Map([iterable])` —— 创建 map，可选择带有 `[key,value]` 对的 `iterable`（例如数组）来进行初始化。
- `map.set(key, value)` —— 根据键存储值，返回 map 自身。
- `map.get(key)` —— 根据键来返回值，如果 `map` 中不存在对应的 `key`，则返回 `undefined`。
- `map.has(key)` —— 如果 `key` 存在则返回 `true`，否则返回 `false`。
- `map.delete(key)` —— 删除指定键对应的值，如果在调用时 `key` 存在，则返回 `true`，否则返回 `false`。
- `map.clear()` —— 清空 map 。
- `map.size` —— 返回当前元素个数。

与普通对象 `Object` 的不同点：

- 任何键、对象都可以作为键。
- 有其他的便捷方法，如 `size` 属性。

### `Set` —— 是一组唯一值的集合。

方法和属性：

- `new Set([iterable])` —— 创建 set，可选择带有 `iterable`（例如数组）来进行初始化。
- `set.add(value)` —— 添加一个值（如果 `value` 存在则不做任何修改），返回 set 本身。
- `set.delete(value)` —— 删除值，如果 `value` 在这个方法调用的时候存在则返回 `true` ，否则返回 `false`。
- `set.has(value)` —— 如果 `value` 在 set 中，返回 `true`，否则返回 `false`。
- `set.clear()` —— 清空 set。
- `set.size` —— 元素的个数。

在 `Map` 和 `Set` 中迭代总是按照值插入的顺序进行的，所以我们不能说这些集合是无序的，但是我们不能对元素进行重新排序，也不能直接按其编号来获取元素。

### 将Map和对象之间相互转换的方法

```js
//理解entries：将所有的键和值组成下面的数据类型
let entries=[[k1,v1],[k2,v2],...,[kn,vn]]
//将entries作为参数，即可转化为对象
let obj=Object.fromEntries(entries)
//通常map作为参数会自动转化为entries
let map=new Map([[k1,v1],[k2,v2],...,[kn,vn]])
let obj=Object.fromEntries(map)
//把对象转为map
let map=new Map(Object.entries(obj))
```

## weakmap和weakset

`WeakMap` 是类似于 `Map` 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问它们，便会将它们与其关联值一同删除。

`WeakSet` 是类似于 `Set` 的集合，它仅存储对象，并且一旦通过其他方式无法访问它们，便会将其删除。

它们的主要优点是它们对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除。

这是以不支持 `clear`、`size`、`keys`、`values` 等作为代价换来的……

`WeakMap` 和 `WeakSet` 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 `WeakMap` 或 `WeakSet` 的键，那么它将被自动清除。

【我的理解】

根据垃圾回收机制，如果内存中的对象没有任何引用可以访问到它，那么就会导致该内存被自动清理，而在一般的map和set中如果使用对象作为键，对象依然可以被访问到，因此即使没有别的引用，对象依然不会被回收

在weak系列中，由于不确定对象是否依然存在，导致原本的 `clear`、`size`、`keys`、`values` 这些方法不能使用，而保留了`set,get,has`应用于存储和外部对象有关的数据或缓存中。

## 对象的values、keys和entries

1. 使用方法

   ```js
   let stu={
       name:'lily',
       age:22
      
   }
   Object.keys(stu);//['name','age']
   Object.values(stu);//['lily',22]
   Object.entries(stu);//[['name','lily'],['age',22]]
   ```

2. 对象的方法和map方法的区别

   map的values、keys和entries方法返回的是可迭代对象，可以用来遍历迭代，也可以转化为真正的数组使用，但不能直接作为真正的数组，需要转化。

   对象的values、keys和entries方法返回的就是真正的数组。

## 赋值解构

解构赋值

1. 解构数组

   ```js
   let arr=[1,2,3,4,5]
   let [num1,num2,num3=0,...rest]=arr
   结果：num1=1,num2=2,num3=3,rest=[4,5],其中num3的默认值为0
   ```

2. 解构对象

   ```js
   let bar={
   	height:200,
   	width:100,
   	title:'sidebar',
   	color:'indigo'
   }
   let {height:h=100,width:w,...rest}=bar;
   结果：h=200,w=100,rest={title:'sidebar',color:'indigo'},其中通过属性名来映射，赋值给变量h和w
   ```

   

3. 智能传参的方法：需要使用大量的默认值，只传入单独的几个参数的时候可以这么做

   ```js
   //将参数列标放入一个解构对象的表达式中，并且将它的默认值设为{}这样不用传参也可以调用
   function sidebarAttr({height=100px,width=200,title="menu",item=[]}={}){}
   pars={item:['item1','item2']}
   sidebarAttr(pars)
   ```

## 时间日期

【总结部分】

- 在 JavaScript 中，日期和时间使用 [Date](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date) 对象来表示。我们不能只创建日期，或者只创建时间，`Date` 对象总是同时创建两者。
- 月份从 0 开始计数（一月是 0，范围是0-11）。
- 一周中的某一天 `getDay()` 同样从 0 开始计算（0 代表星期日）。
- 当设置了超出范围的组件时，`Date` 会进行自我校准。这一点对于日/月/小时的加减很有用。
- 日期可以相减，得到的是以毫秒表示的两者的差值。因为当 `Date` 被转换为数字时，`Date` 对象会被转换为时间戳。
- 使用 `Date.now()` 可以更快地获取当前时间的时间戳。

【常用方法】

1. 格式化相对日期：可以用于信息发布时间的显示

   ```js
   function formatDate(date){
       let now=new Date();
       let diff=(now-date);
       // 1s之内
       if(diff<1000)
       return ("right now");
       //一分钟以内
       let sec=Math.floor(diff/1000);
       if(sec<60)
       return `${sec} sec. ago`;
       let min=Math.floor(diff/60000);
       //一小时以内
       if(min<60)
       return `${min} min. ago`;
       
       //标准化格式：DD.MM.YY HH:mm
       let dayOfMonth = date.getDate();
     	let month = date.getMonth() + 1;
     	let year = date.getFullYear();
     	let hour = date.getHours();
     	let minutes = date.getMinutes();
       
       year = year.toString().slice(-2);
     	month = month < 10 ? '0' + month : month;
     	dayOfMonth = dayOfMonth < 10 ? '0' + dayOfMonth : dayOfMonth;
     	hour = hour < 10 ? '0' + hour : hour;
     	minutes = minutes < 10 ? '0' + minutes : minutes;
       return `${dayOfMonth}.${month}.${year} ${hour}:${minutes}`
       
       
     }
   
   ```

   2. 创建日期的方法

   ```js
   //创建2021-12-30,时间部分不写默认为0
   // new Date(year, month, date, hour, minute, second, millisecond)
   let date=new Date(2021,11,30)
   ```

   3. 显示星期简写

   ```js
   function getWeekDay(date){
       let week=['SU','MO'，'TU'，'WE'，'TH'，'FR'，'SA']
       return week[date.getDay()]
   }
   ```

   4. 返回多少天以前的日期

   ```js
   //一般不希望给出的日期被修改，因此一般会复制当前日期
   function getDateAgo(date, days) {
     let dateCopy = new Date(date);
   
     dateCopy.setDate(date.getDate() - days);
     return dateCopy.getDate();
   }
   
   let date = new Date(2015, 0, 2);
   
   alert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
   alert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
   alert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)
   ```

   

   5. 返回一个月的最后一天

   ```js
   //利用0表示上个月最后一天
   function getLastDayOfMonth(year, month){
   let date=new Date(year,month+1,0);
   return date.getDate();
   }
   ```

## JSON方法

   1. json是一种数据格式，它可以将对象转化为字符串在网络中传输，或者在日志中输出。符合以下的一些规范：

      1. json中不使用单引号，字符串和键名都是用双引号标注

      2. json中不添加注释

         

   2. JavaScript 提供序列化（serialize）成 JSON 的方法 

      ```js
      /*value:对象本身，
      
      replacer，属性名列表:列表中的属性才会被提取到json中 
      
      或 键值函数：根据每组键和值决定如何创建json，
      function(key,value){
      	if(key=='name') 
      	return undefined;
      	else
      	return value;
      }
      
      space 嵌套的属性缩进的空格数量*/
      let json = JSON.stringify(value[, replacer, space])
      ```

   3. json转化为对象（和解析 JSON 的方法）

```js
//语法，str是json格式的字符串，reviever是对每一对键值都会使用一遍的处理函数，这就经常使用在一些对象的属性值也是对象，就要把json中的字符串重新来生成这个对象，作为它的属性值
let value = JSON.parse(str, [reviver]);
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( meetup.date.getDate() ); 
```
   4. tojson方法，指定对象转化为json结果

      ```js
      let room = {
        number: 23,
        toJSON() {
          return this.number;
        }
      };
      //json结果为23，而不是"number":23
      ```

  
