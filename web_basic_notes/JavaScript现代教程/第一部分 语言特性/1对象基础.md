## 对象方法，this

- 在JavaScript中，每个函数`f()`都可以有`this`对象，

  - 如果这个函数被调用了`obj.f()`，那么`this`所指的就是`obj`，`this` 就是点符号前面的对象。
  - 而其他情况下`this`为`undefined`，

  ==因此this的值是程序运行时得到的==。

- 箭头函数没有this，箭头函数内部访问到的this是来自它们外部的正常函数

- this在类和对象中。

  类：在函数中，this一开始指向的是window，当new了之后就分配了内存空间，this就指向了这个内存，从而绑定了这个对象自己的方法。

```js
function Worker(){
    this.slow=function(){
        alert(this);//obj:slow,dance
        this.dance();
    }
    this.dance=function(){
        alert('dacing');
    }
    alert(this);//worker()调用的时候弹出obj window，new了之后obj:slow,dance
}
worker()
let worker=new Worker()
```

​	对象：对象中的this都是指向该对象的

```js
let worker={
    name:'j',
    show(){
        alert(this.name)
    }
}
worker.show()//j,说明内部的this指向对象worker

```



## 构造函数，JavaScript的构造函数写法

- new的原理
- 公共约定：构造器的首字母大写
- 如果在构造器中添加return语句，只有在返回对象的情况下会覆盖`return this`，否则一律`return this`

```js
function User(name){
    this.name=name;
    this.sayHi()=function(){
       alert("Hi,this is"+this.namew) 
    }
}
let user=new User();
/*new的原理
1.创建新的内存空间
2.隐式创建this，this指向该空间
3.this添加属性和方法到该对象中，构造函数不同于直接创建对象，方法和属性都要通过this绑定
4.隐式的进行 return this
*/
```

注意区分类和对象，以上是一个User类，以下是一个user对象，比较像一个键值对

```js
let user={
	name:'Lily',
    sayHi(){
        alert("Hi,this is Lily")
    }
}
```

## 可选链

```js
// 01 如果属性存在返回obj.attr，否则返回undefined
obj?.attr

// 02 如果属性存在返回obj[attr]，否则返回undefined
obj?.[attr]

// 03 如果方法存在返回obj.func()，否则返回undefined
obj.func?.()
```

不要滥用可选链

- 一般来说obj都是已经存在的对象，只是不确定它是否有这个属性或者方法
- 如果obj没有声明，直接报错；obj没有赋值不会报错，但是不建议这么做

## Symbol类型

- 使用Symbol可以创建唯一标识符
- 创建方法，通过带有描述的Symbol创建：`let id=Symbol("id")`
- 特点
  - 即使描述相同，每次创建的变量也都不相等；
  - 使用Symbol类型作为对象的属性名不会出现在for in循环中；
  - 如果要创建相同值的Symbol，则使用Symbol.for("discription")；

- 应用场合：“隐藏对象属性”，系统的Symbol

【参考总结】

`Symbol` 是唯一标识符的基本类型

Symbol 是使用带有可选描述（name）的 `Symbol()` 调用创建的。

Symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 Symbol 相等，那么我们应该使用全局注册表：`Symbol.for(key)` 返回（如果需要的话则创建）一个以 `key` 作为名字的全局 Symbol。使用 `Symbol.for` 多次调用 `key` 相同的 Symbol 时，返回的就是同一个 Symbol。

Symbol 有两个主要的使用场景：

1. “隐藏” 对象属性。 如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 Symbol 并使用它作为属性的键。Symbol 属性不会出现在 `for..in` 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。

   因此我们可以使用 Symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。

   

   鉴于这个方法比较实用，这里写个小案例：为入队的猫狗添加时间戳属性。

   - 需要注意的是添加属性的方法，在chrome中测试发现，使用`object[key]=value`这样的格式，以symbol为属性名的属性才不会被`for...in..`循环显示出来。

   ```js
   let timestamp=0;
       let time = Symbol("time"); 
   
       this.enterQ=function (ani){
           //打时间戳
           ani[time]=timestamp++;
           if(ani.type=='dog')
           qdog.enqueue(ani);
           else if(ani.type=='cat')
           qcat.enqueue(ani);
       }
   ```

   

2. JavaScript 使用了许多系统 Symbol，这些 Symbol 可以作为 `Symbol.*` 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 `Symbol.iterator` 来进行 [迭代](https://zh.javascript.info/iterable) 操作，使用 `Symbol.toPrimitive` 来设置 [对象原始值的转换](https://zh.javascript.info/object-toprimitive) 等等。

从技术上说，Symbol 不是 100% 隐藏的。有一个内建方法 [Object.getOwnPropertySymbols(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) 允许我们获取所有的 Symbol。还有一个名为 [Reflect.ownKeys(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys) 的方法可以返回一个对象的 **所有** 键，包括 Symbol。所以它们并不是真正的隐藏。但是大多数库、内建方法和语法结构都没有使用这些方法。

## 对象-原始值转换

javascript中没有对于运算符的重载，对于对象的加减操作等情况则需要将对象转化为原始值

1. 三种类型（三种转换的类型）
   - “string"：alert(obj)，在做一些输出显示的操作时，会将hint设为string
   - "number"：obj1*obj2，在做一些计算操作时，会将hint设为number
   - "default：无法确定是转化为string还是number

2. 转换方法
   - 优先`[Symbol.toPrimitive](hint)`
   - hint=="string",toString(),valueOf()
   - hint=="default",hint="number",valueOf(),toString()

3. 重写方法演示

```js
let worker={
    name:"Lily",
    money:30000,
    [Symbol.toPrimitive](hint){
        return hint=="string"?`name:${this.name}`:this.money

    }
}
// hint=="string"
alert(worker)
// hint=="number"
alert(12*worker)
```

```js
//一般来说对象转换为字符串输出对象的一些重要信息，而不需要转换为数字，一般不做运算操作
let dagongren={
    name:"Lily",
    money:30000,
    toString(){
        return `the worker is ${this.name}, the salary is ${this.money}`
    }
}
```



