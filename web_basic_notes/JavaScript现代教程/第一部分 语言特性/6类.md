## class语法

MyClass本质是一个函数，`MyClass==MyClass.prototype.constructor`

类里面的构造器和其他方法都会写进类的原型中（`MyClass.prototype`）

类里面的字段不会写进原型中，而是会单独分配给每个对象中，作为对象的属性

class不是语法糖，class声明的类必须通过new之后才能创建新的对象，直接调用`MyClass()`的话会报错。

```js
class MyClass {
  prop = value; // 属性

  constructor(...) { // 构造器
    // ...
  }

  method(...) {} // method

  get something(...) {} // getter 方法
  set something(...) {} // setter 方法

  [Symbol.iterator]() {} // 有计算名称（computed name）的方法（此处为 symbol）
  // ...
}
```

### new之后进行的工作

*针对于通常的类，不包含类继承的情况*

1. 调用构造器，开辟一段内存空间，使用this指向它，执行构造器中的语句，一般来说会绑定一些属性
2. 将创建好的对象，通过指针[[prototype]]指向这个类的原型，类的原型本身也是一个对象，其中包括了类中的构造器和所有方法

## 类继承

### 继承extends

1. js中继承的语法

```js
class Animal{}
class Rabbit extends Animal{}
```

2. 继承之后的对象关系

   ![image-20220509143344100](C:\Users\祁馨亮.LAPTOP-M8E4TH4B\AppData\Roaming\Typora\typora-user-images\image-20220509143344100.png)

此时Rabbit创建的对象即可使用Rabbit原型对象和Animal原型对象中的方法

### 方法的重写

使用super可以对于父类中的方法进行调用

```js
class Rabbit extends Animal{
hide(){
    alert(`${this.name} hides.`)
}    
stop(){
    super.stop();
    this.hide();
}
}
```



### new的行为：在继承的情况下

1. 父类的构造器必须被调用，因此需要使用super来首先使用super来调用父类的构造器，再编写子类的构造器语句。没有子类的构造器时，会默认调用父类的构造器
2. 搭建对象和原型对象之间的指针，详细的情况可以看上面的图

### 重写类字段

这里需要了解一个顺序，在创建有父类的对象时，对象的内存陆续添加以下内容：

1. 父类的类字段
2. super构造器带来的属性
3. 子类的类字段
4. this构造器带来的属性

所以在这个过程中，假设我们不编写子类的构造器，而在父类的构造器中访问在子类中重写的类字段，会出现错误，因为子类的类字段还没有对父类的字段进行覆盖，示例如下：

```js
class Animal{
    flurry=false;
    constructor(){
        console.log(`${this.flurry}`)
        console.log("parent cons")
    }
}
class Rabbit extends Animal {
    flurry=true;
    constructor() {
        super()
        console.log(`${this.flurry}`)
        console.log("child cons")
    }
}
new Rabbit()
____________________________________________________________
false
parent cons
true
child cons
```

## super的实现原理

### 不使用this的原因

因为当继承链条上多个对象的时候，会产生一个诡异的死循环，详见 https://zh.javascript.info/class-inheritance#shen-ru-nei-bu-tan-jiu-he-homeobject

### [[HomeObject]]属性

1. 对象方法可以通过`[[HomeObject]]`属性来获得对象本身，以此来实现super需要实现的功能
2. `[[HomeObject]]` 是为类和普通对象中的方法定义的。但是对于对象而言，方法必须确切指定为 `method()`，而不是 `"method: function()"`。

3. 正如我们之前所知道的，函数通常都是“自由”的，并没有绑定到 JavaScript 中的对象。正因如此，它们可以在对象之间复制，并用另外一个 `this` 调用它。this的值是在有具体对象调用它时确定的，但是super并非如此

   `[[HomeObject]]` 的存在违反了这个原则，因为方法记住了它们的对象。`[[HomeObject]]` 不能被更改，所以这个绑定是永久的。教程中的例子方便理解

   ```js
   let animal = {
     sayHi() {
       alert(`I'm an animal`);
     }
   };
   
   // rabbit 继承自 animal
   let rabbit = {
     __proto__: animal,
     sayHi() {
       super.sayHi();
     }
   };
   
   let plant = {
     sayHi() {
       alert("I'm a plant");
     }
   };
   
   // tree 继承自 plant
   let tree = {
     __proto__: plant,
     sayHi: rabbit.sayHi // (*)
   };
   
   tree.sayHi();  // I'm an animal (?!?)
   ```

   

## 静态方法和静态属性

### 静态方法

static语法

```js
class Animal{
    constructor(name,speed){
        this.name=name;
        this.speed=speed;
    }
    static compare(ani1,ani2){
        return ani1.speed-ani2.speed;
    }
}
```



1. 静态方法是类本身具有的一种方法，所以在使用的时候我们也是通过类名来调用它
2. 在存储上，静态方法存放在类（作为一个函数）自己的内存空间中，详细可以参下图，compare就是一个Animal的静态方法
3. 静态方法可以被继承，实现的方法是通过在`Rabbit`和`Animal`之间连接`[[prototype]]`

![image-20220510151307897](..\img\image-20220510151307897.png)

### 使用静态方法来创建对象

工厂方法，this指向的是Stu，最终仍然是调用了构造器

```js
class stu{
    constructor(name,time){
        this.name=name;
        this.time=time;
    }
    static createTodayStu(name){
        return new this(name,Date.now())
    }
}
let stu=Stu.createTodayStu('Lily')
```



### 静态属性

```js
class Animal{
    static planet='Earth';
    constructor(name,speed){
        this.name=name;
        this.speed=speed;
    }
    static compare(ani1,ani2){
        return ani1.speed-ani2.speed;
    }
}
Animal.planet;
```

## 私有的和受保护的属性和方法

### 受保护的属性

_属性名

1. 将属性设置为受保护的类型，可以同时为它设置一个访问器，我们只通过访问器对它进行get和set，在编写get和set的过程中就可以限制受保护属性值的改变情况。

2. 受保护的属性是可以被继承的

   针对1中描述的情况举例

   ```js
   //小组活动的次数只能是非负数
   class Group{
       constructor(name,count){
           this.name=name;
           this._count=count;
       }
       get count(){
           if (this._count<0)
              return 0;
           else
              return this._count;
       }
       set count(count){
           if (count<0)
               this._count=0;
           else
              this._count=count;
       }
   }
   ```

### 私有的属性

#属性名

1. 私有的属性只能在类的内部被访问
2. 私有属性不能够被继承

## 扩展内建类

1. 可以让新的类继承自js中的内建类，以此来给他们增加功能，以下例子：

   众所周知，js数组实现了pop和push的功能，传统的stack一般来说还需要有判空函数，因此正好可以基于Array进行扩展

   ```js
   class Stack extends Array{
       isEmpty(){
           if(this.length==0)
               return true;
           else
               return false;
       }
   }
   ```

2. 内建类之间的继承是不会继承静态方法的，比如说Date继承自Object，但是Object的静态方法key和value，Date是没有的。

## 类检查 instanceof

1. instanceof是一个操作符，它可以判断一个对象是否属于某一类。
   - 考虑了继承，会将原型链考虑在内，只要类在对象的原型链上都会返回true

2. instanceof运算符的执行流程

   1. 系统内部的[Symbol.hasInstance]方法（`@params:obj @return {boolean}`）：可以允许用户自己定义判断一个对象是否属于该类的方法

   2. 一般来说[Symbol.hasInstance]是没有定义的，所以js会判断对象的原型是否是类的prototype，以及原型的原型

      ```js
      obj.__proto__ === Class.prototype
      obj.__proto__.__proto__ === Class.prototype
      obj.__proto__.__proto__.__proto__ === Class.prototype
      ...
      // 如果任意一个的答案为 true，则返回 true
      // 否则，如果我们已经检查到了原型链的尾端，则返回 false
      ```

3. 使用`Object.prototype.toString.call(obj)`可以直接判断某对象属于原始类型和内建类中的哪一种，之所以要将toString借出是因为`obj.toString`和可能在继承了Object之后根据实际的需要重写toString方法，比如一些类型的特定转换方式，number转成string，而无法用于判断类型

   如果想让自己定义的类也通过上述的方法确定对象的类型，需要在类中给[Symbol.toStringTag]赋值类名

   ```js
   class Animal{
       [Symbol.toStringTag]="Animal";
   }
   alert(Object.prototype.toString.call(new Animal()))//[object Animal]
   ```

   ## Mixin 模式

   1. 含义：在js的单继承模式下，使用它将行为添加入类中，但是不通过继承

   2. 一般的使用方法，将行为放在某个对象中，将对象分配给某个类的prototype

      ~~~js
      let mixin={
          func1(){}
          func2(){}
      }
      Object.assign(Class.prototype,mixin)
      
      ~~~

      - 需要注意mixin中的方法尽量避免和类中的方法名重复而产生冲突
