## js-原理

### 原型链

自顶向下

1. 顶层对象：js中设计了Object.prototype和它的构造函数Object
   - 对象原型没有进一步的源头了，所以`Object.prototype.__proto__==null`
   - 对象构造器是一个构造器对象，所以`Object.__proto__==Function.prototype`
2. 顶层构造器：js中设计了Function.prototype和它的构造函数Function
   - 由于它本身也是对象，`Function.prototype.__proto__==Object.prototype`
   - 函数构造器是一个构造器对象，所以`Function.__proto__==Function.prototype`

3. 普通对象：每个对象都有`__proto__`属性（原型链属性，js中的非标准属性，可以使用Object.getPrototypeOf获得），它指向对象的原型对象，也可以理解为是对象的构造函数的prototype所指向的对象。
4. 构造器：构造器不仅有`__proto__`属性，同时也有`prototype`属性，前者指向构造器作为一个对象本身，这个对象的原型，后者指向构造器构造出来的对象的原型对象。
5. 对象原型：对象原型包含了对象可以使用的属性和方法。

## Vue-basic

### Vue渐进式

允许开发者按照项目开发的需求，将所需要的功能逐步引入到项目中，实现定制化的开发

### single page application

含义：SPA是一种构建web应用的方式，它只有一个页面和一些必要的静态资源，其他的内容都是通过js动态生成的。

例子：SPA 通过路由机制，将页面的不同部分（视图）映射到不同的组件，实现了在同一个 HTML 页面内动态地加载不同的组件，从而达到切换页面的效果。

优点：用户体验好，局部刷新方便更快交互；缺点：不利于seo

### MVVM & MVC

1. mvc

   model和程序中数据相关的业务逻辑，

   view做页面上数据的展示，

   controller做程序的流程控制（处理输入，操作数据，调用视图）

2. mvvm

   view-model：实现了视图和数据的双向绑定，操作任意一方都可以同步变化

   优势：精简代码，不用频繁操作dom，让开发者把注意力都放在对于数据的操作上

   vue中的view和model之间还可以通过ref进行通信，不是标准的mvvm

### vue修饰符

| 修饰符              | 作用                                                   |
| ------------------- | ------------------------------------------------------ |
| lazy                | 懒加载，等到停止输入内容（光标离开input）再更新value值 |
| trim                | 去除字符串两端的空格                                   |
| number              | 限制输入的内容为整数，去除数字后面的其他字符           |
| stop                | 阻止冒泡                                               |
| capture             | 改为捕获                                               |
| self                | 只触发真正被点击的元素绑定的事件                       |
| once                | 事件只被调用一次                                       |
| prevent             | - 阻止默认事件（a标签的跳转）                          |
| native              | - 保证自定义组件的事件可以触发                         |
| left、right、middle | 设定鼠标按键触发的点击事件                             |
| passive             | scroll事件的懒加载                                     |
| camel               | - 将绑定的参数识别为驼峰                               |
| sync                | - ？                                                   |
| keyCode             | 设定按下某个键盘键触发的事件                           |

### vue指令

Vue的v指令是用来添加响应式行为和绑定数据的。这些指令的共同性在于它们都可以用来操作DOM，根据指令的不同，可以实现不同的功能。

1. v-bind(:)——实现vue实例数据流向dom元素属性，常用于绑定dom动态属性
2. v-on(@)——实现将dom元素事件绑定到vue实例中，用于设置事件处理程序
3. v-model——实现vue实例中表单数据和dom表单双向绑定，本质上是`:value`和`@input`的语法糖，为了避免value和页面渲染的不同步，必须把表单声明为响应式
4. v-for——实现根据vue实例数据渲染相应的dom元素
5. v-slot——根据插槽名，在组件中合适的位置插入自定义的dom节点
6. v-if——如果表达式的值为真，则渲染对应的元素；如果表达式的值为假，则不渲染对应的元素。
7. v-show——无论表达式的值是真是假，元素都会被渲染到页面中。如果表达式的值为真，则显示元素；如果表达式的值为假，则隐藏元素（`display:none`）

【二者的区别】

- v-if值的切换会导致组件重复地跑声明周期，所以用于按照逻辑渲染，后期不用频繁切换的场景
- v-show只是在页面上隐藏渲染好的节点，应用于频繁切换的场景

### 组件间传值的方式

1. 父组件->子组件：子组件的属性，props
2. 子组件->父组件：父组件在子组件上监听特定事件`@event=hanlde(value)`，子组件发布事件传递参数`$emit('event',value)`
3. 使用Vuex进行状态管理
4. 使用localStorage缓存键值对

5. 使用$refs可以获取绑定了ref属性的组件实例，通过它自身的方法就可以传递数据

### web应用程序路由的两种实现方式

1. hash：浏览器只加载#前面的内容，后面的url发生变化，触发window的hashchange事件，以此来更新页面路由。
2. history：通过`pushState`和`replaceState`切换url，实现路由切换。可以根据历史状态的不同，恢复之前的页面，从而不需要重新加载整个页面。适用于同一个页面的状态切换。

### 动态样式

可以通过动态地绑定（v-bind）class和style属性，可以给他们绑定关于class和style的对象或数组

### computed和watch的区别

1.`computed`是依赖已有的变量来计算一个目标变量，大多数情况都是`多个变量`凑在一起计算出`一个变量`，并且`computed`具有`缓存机制`，依赖值不变的情况下其会直接读取缓存进行复用，`computed`不能进行`异步操作`

2.`watch`是监听某一个变量的变化，并执行相应的回调函数，通常是`一个变量`的变化决定`多个变量`的变化，`watch`可以进行`异步操作`

### vue的生命周期

vue组件会经历的一系列初始化步骤，允许开发者在需要的阶段运行自己的代码，ipad上同步更新对每个阶段的理解

<img src=".\ref_img\lifecycle.png" alt="lifecycle" style="zoom: 67%;" />

### 父子组件的生命周期

父beforeCreate->父Created->父beforeMount（因为这里开始编译模板，会识别到子组件的存在）->子beforeCreate->子Created->子beforeMount->子Mounted->父Mounted

父组件的生命周期会影响到子组件，当父组件被销毁，vue会递归销毁其子组件（深度优先遍历）

而当子组件被销毁时，很可能对父组件没有影响

### 为什么v-if和v-for不建议用在同一标签

因为v-for的优先级高于v-if，虚拟节点会先通过循环全部被渲染出来，之后v-if会对他们进行逐一的判断，这样就进行了很多无用的渲染操作

解决方案：在computed中使用filter将需要渲染的节点选出来，在进行for循环

### ==自定义v指令==

1. 了解整套注册流程
2. 案例实现防抖按钮 

### vuex的属性和作用

- state：统一管理应用状态的对象。

- mutation：唯一用来改变应用状态的方法（同步方法），集合在一个对象中。如果修改应用状态的方法需要维护，只需要修改这一个地方。

- action：可以将mutation中的一些操作放到异步任务中，来实现异步地修改某一个变量。

  我的理解：一种经常发生的异步操作并且最终触发了应用状态的改变，用于不同的组件之间，就适合放到action。

- getter：可以从store中获取数据，主要是对store中的数据进行一个包装的作用，不会修改store中的原数据，并且是响应式的，会随着store数据的变化而变化。

- module：可以将多个组件的store（都有自己的state,mutation,action,getter）应用到同一个应用的store中，并且有自己的命名空间，当应用涉及到的状态变量很多时，这样方便管理维护。

### 插槽知识点

【基本使用概念】

1. 插槽的目的：在子组件的内部能够放入父组件创建的相关节点

2. 默认内容：在子组件的内部可以设置插槽处的默认值

3. 具名插槽：可以在子组件的不同节点位置设置插槽并且命名，父组件按照插槽的名称插入自己的节点

4. 插槽作用域：插槽可以将子组件上绑定的子组件数据传递给父组件，父组件通过v-slot的值来接收这些子组件数据

   ```vue
   //子组件绑定 组件名student
   <slot :name="Amy" :age="12">
   //父组件接收
   <student v-slot="slotProps">
       {{slotProps.name}}-{{slotProps.age}}
   </student>
   //具名插槽使用下面语句
   #slot-name="slotProps"
   ```

【大致解析原理】

1. 普通插槽

   解析父组件，生成slot处的虚拟节点->根据插槽名放入到子组件的对应位置`_t(slot-name)`

2. 作用域插槽

   解析父组件，生成slot处的函数->解析子组件，封装绑定的子组件数据，调用父组件slot处函数生成slot对应的虚拟节点，根据插槽名放入到子组件的对应位置`_t(slot-name,obj)`

### 在v-for中，为什么不建议用index做key

因为index在数组中的数据项增加或减少的时候，都会可能会发生改变（unshift、shift）。而使用id，这种固定不变且唯一的属性就非常合适。所以不要选择容易改变的属性作为key

### nextTick的用处

这个和vue的异步更新队列有关，响应式数据改变之后，dom的同步更新不是立即执行的，而是放入一个任务队列，等待下一个tick立即执行。而在tick中，不会发生页面的重新渲染。

`$nextTick()` 方法用于在 DOM 更新周期结束后执行回调函数。当你修改 Vue 实例中的数据时，Vue 会异步地更新视图，这意味着在数据变更后，DOM 元素并没有立即更新。如果你想要在 DOM 更新之后执行一些操作，例如操作更新后的 DOM 元素，那么就可以使用 `$nextTick()` 方法。

## Vue2

### data函数

因为每个组件都可能多次被调用，而每次调用前都会再执行一次data函数，获得数据的初始化状态，以防数据污染。

### 不需要的响应式数据处理方法

对于从头到尾都不会改变的“死数据”应当做非响应式的处理，以此减少开销。

使用`Object.freeze()`定义对象，并在data中返回对象

### watch vue2

1. 监听基本类型

   ```js
   data(){
       return{
           message:"hello world";
       }
   },
   watch:{
       message(newValue,oldValue){
           //回调函数
       }
   }
   ```

2. 监听对象

   ```js
   data(){
       return{
           student:{
               name:"zhangsan",
               age:23
           }
       }
   },
   watch:{
       student:{
           handler(newValue, oldValue) {
           console.log('student changed from', oldValue, 'to', newValue)
         },
         deep: true//深度监听才会关注对象的属性是否发生改变，否则关注对象名引用
         immediate:true//在组件初始化之后就立即执行回调函数，一般默认为false，组件挂载之后再监听变化，执行回调函数
       }
   }
   ```

### 对象新属性无法更新视图，删除属性无法更新视图

- 原因：`Object.defineProperty`没有对对象的新属性进行属性劫持
- 对象新属性无法更新视图：使用`Vue.$set(obj, key, value)`，组件中`this.$set(obj, key, value)`
- 删除属性无法更新视图：使用`Vue.$delete(obj, key)`，组件中`this.$delete(obj, key)`

## Vue3

### vue3的响应式变量应用

1. 为什么要使用reactive函数？

   vue3项目中，onMounted之后就完成了页面dom的渲染，此时再去修改组件的某些值也无法实现在页面上的重新渲染。

   当我们需要页面随着数据的改变而重新进行局部的渲染，则需要吧这些数据声明为响应式的

2. reactive的原理简单理解？

   Reactive 实现的原理是通过 Object.defineProperty 在对象属性 getter 和 setter 方法上==添加依赖追踪==，通过闭包来==捕获并管理依赖关系==。当对象中某个属性的值发生变化时，setter 会==通知观察者并触发重新渲染==。

   观察者模式：观察者模式是一种设计模式，它定义了对象之间的一对多关系，当一个对象改变状态时，他的所有依赖都将收到通知并自动更新。主体和观察者之间形成了一种松耦合的关系，因此观察者可以动态地注册和注销，而不会影响到主体的其他部分。

3. reactive和ref

   - ref: ref 是一个响应式的单个值，它可以通过 .value 属性读写数据。
   - reactive: reactive 是一个响应式对象，它可以包含多个值，通过读写对象属性来读写数据。

### vue3的单向数据流

1. 循环更新

   循环更新发生在两个组件之间，当一个组件中的响应式对象改变时，会更新另一个组件中使用的响应式对象，而该对象又会更新第一个响应式对象，以此类推。这样会形成一个更新的无限循环，可能导致意料之外的行为，例如错误，崩溃或无限渲染。

2. 单向数据流原则：为了避免 Vue3 中的循环更新，你应该遵循单向数据流原则，也就是数据只从父组件向子组件流动，不会反过来。这意味着子组件不应该修改来自父组件的 prop，而是应该通过事件或者回调将数据传回父组件。


### onMounted+事件监听

知识点：vue3中的事件监听，图表resize

1. 对于`onMounted`的理解

   - 组件挂载：Vue3中的组件挂载指的是将组件与页面中的 DOM 元素对应起来的过程。在 Vue 中，每个组件都有一个对应的虚拟 DOM，而挂载的过程即是将组件的虚拟 DOM 映射到真实的 DOM 上。在组件挂载完成后，组件可以对页面中的 DOM 元素进行操作，并对用户的交互产生反应。
   - 虚拟dom->真实dom： 组件的信息在编译过程中被转换为真实的 DOM。Vue 在挂载组件时，会先将组件的虚拟 DOM 编译为 JavaScript 代码，再执行该代码以生成真实的 DOM。编译过程中，Vue 会考虑组件的模板、数据、事件等信息，并将其映射到真实的 DOM 元素上。这样，组件的信息就可以通过真实的 DOM 展示到页面上，并对用户交互做出反应。
   - onMounted时间点：Vue 的 `onMounted` 钩子函数在组件被挂载完成之后执行。也就是说，组件的虚拟 DOM 已经被编译为真实的 DOM，并与页面上的 DOM 元素对应起来，组件已经可以对页面上的元素进行操作。`onMounted` 钩子函数可以让我们在组件挂载完成后执行一些操作，==比如请求数据、初始化组件状态等==。

   通过以上的内容，可知可在onMounted中对页面上已经存在的图表dom进行操作，也就是在这里对`resize`事件进行一个监听

2. 对`unMounted`的理解

   - 当组件被卸载时，Vue 将会调用 `unmounted` 钩子函数。在该阶段，组件的实例已经不再被需要，并且已经从页面中删除了。==在该阶段，可以执行一些清理操作，如移除事件监听器，清除定时器等，以保证不会对其他组件造成影响==。

   也就是在这个页面组件上由开发者添加的任何监听器，定时器等统一在此处清理。

3. 对事件清理的理解

   当某个组件被卸载时，在它上面安装的监听器也应该被移除，否则当大量的监听器都没能及时清除的时候可能会导致内存的泄漏

## webpack

```
webpack 的基础概念：模块打包、入口、出口等。

webpack 的配置：通过 webpack.config.js 配置打包参数。

webpack 加载器和插件：使用加载器对不同类型的文件进行转换和处理，使用插件增强打包的功能。

webpack 编译和优化：使用 source map 和 tree shaking 等技术，提高代码的可调试性和性能。

webpack 的实际应用场景：如多页面应用、懒加载等。
```

## nodejs

### 基础概念

1. 服务器：处理用户的各类请求并且响应用户

2. nodejs：一个开源和跨平台的JavaScript运行时环境，js通过nodejs可以连接服务器，访问本地文件等，使js可以运行在服务器。

3. node的非阻塞范式，处理高并发

   - nodejs的单线程指的是当函数调用栈中有函数在运行，js是不能处理其他请求的
   - 当在node中创建一个服务器，node会开辟一个线程来处理请求，同时初始化一个调用栈
   - 异步模块：一个任务中的同步操作在调用栈中很快地被执行了，任务中的异步操作则进入异步模块来执行。异步模块是多线程的。当执行结束后有回调函数，则把回调函数放入对应的任务队列，以此来进行事件循环。
   - 事件循环：node中有多个任务队列（timer、poll、check），异步模块也有任务队列（nextTick、micro）。当调用栈为空时（调用栈同步任务完成），会检查这些队列中是否有任务，并且按照一定的顺序将这些队列中的任务逐一执行。这一整个过程叫做事件循环。

4. 异步编程+流程控制

   - 原因：由于node中的非阻塞范式，执行异步操作的时间不同，导致回调函数进入任务队列和最终执行的顺序难以确定，因此根据业务的需要，要做出符合要求的流程控制。

   - 解决方案

     | 流程要求 | 回调函数     | promise          | async、await                           |
     | -------- | ------------ | ---------------- | -------------------------------------- |
     | 顺序执行 | 回调函数嵌套 | `.then`链式调用  | 语法糖：使用同步的书写格式来写异步代码 |
     | 同步执行 | 中间变量控制 | `Promise.all`Api | 同promise                              |

5. 模块、包：

   5.1 CommonJs

   - 模块：一份独立的js文件对应一个自己的module对象，通过`exports`导入，提供一些函数、对象、变量的js文件，有自己的作用域，同时可以通过`require`导出
   - `require()`:
     - 核心模块：随node一起安装，模块名
     - 第三方模块：npm安装，安装在`node_moudles`，模块名
     - 自己写的模块：路径

   5.2 ESmodule

   - 使用export，import导出导入，配置`package-json`中`"type": "module"`

   5.3 区别（待补充）

   CommonJs在运行时加载模块，ESmodule在编译时加载模块

6. npm（Node Package Manager）：用于管理nodejs应用程序所需的模块和模块之间的依赖关系

   - 包：包是一个可以安装到 Node.js 应用程序中的软件包，它可以包含一个或多个模块，以及其他必要的资源。包可以通过 `npm` 进行管理，并且可以在多个应用程序间共享。
   - package.json：用于定义包，该文件包含了包的元数据，如：name、description、version、license、author、dependencies等

7. 事件驱动程序

   - EventEmitter：EventEmitter类用来实现node中的事件驱动，核心就是事件触发`new EventEmitter().emit(event)`与添加事件监听器功能`new EventEmitter().addEventListener(event,handler)`的封装。
   - node中支持事件响应的模块是的`EventEmitter`子类，如http 、fs等

8. Buffer：Buffer 类在 Node.js 中主要用于处理二进制数据。可以将图片文件等二进制内容读入缓冲区，并进行操作，例如读取、写入、转换编码格式等。主要的原因在于js只有处理字符串的api，难以处理以二进制形式存储的网络请求、图片、文件等。

9. Stream模块

   - 目的：就是为了处理端到端的数据交换

   - I/O操作：网络请求、文件读取等
   - 流模式：发送方->缓冲区->接收方，流模式是将大量数据分割成小块，逐块地处理并传输，这样可以保证数据的流畅接收。在 Node.js 中，stream 模块提供了一种实现流模式的方法。通过流模式，我们可以避免将整个文件一次性读入内存，从而降低内存压力，提高程序效率。
   - Stream：提供流接口的api，提供了各种流的实现，如可读流，可写流和双工流。它们都是基于EventEmitter的，所以它们可以绑定事件以监听数据的流动。

10. nodejs在项目中的应用

    1. 服务器端渲染：在服务器运行js并且请求后端数据，将最终渲染好的页面发送给浏览器运行
    2. 写后台：使用nodejs编写后端逻辑，给前端提供访问数据的接口
    3. 提供npm包管理器：可以方便地安装和管理 Vue 相关的开发工具和第三方库。

## 计网基础

###    跨源请求

   1. 基础概念

      - 源（origin）：域（domain）/端口（port）/协议（protocol）的组合。
      - 域名（Domain Name）：是一个字符串，代表一个网络上的计算机的地址。它是对于网络中使用数字地址（如IP地址）的一个抽象层次。域名是用来替代数字地址，以方便用户记忆和识别。
      - IP地址：计算机在 Internet 中的唯一标识。
      - DNS：DNS (Domain Name System) 是一个基于分布式数据库的系统，它把 Internet 上每个主机名和 IP 地址进行了映射，使得人们可以通过主机名访问网站，而不需要记住每个网站的 IP 地址。
      - 安全跨源请求流程：浏览器发送请求，请求中包含origin->服务器确定origin是被允许的源，服务器发送包含`Access-Control-Allow-Origin`响应->浏览器拿到服务器发送的结果

   2. 开发环境下的跨源请求

      可以把vue和flask项目看作服务器，他们的主机ip+端口号可以确定一个网络服务器的地址，但是它不是一个独特的域名。这两个项目之间的通信也需要设置跨源请求，但是不需要指定源。

        知识点3：`FormData`对象

         - 这是一个表单数据对象，可以用来捕获html表单，同时很多方便的方法自己添加字段，如`formData.append(key,val)`，之后使用一些网络方法提交这些表单数据。
         - 本功能中使用它来像后台发送文件，发送包含文件的请求需要在请求头中设置`'Content-Type': 'multipart/form-data'`
         - flask中`request.files`是一个字典，保存了请求中所有文件名和文件内容形成的键值对，可以用来保存文件到后台

### `FormData`对象

   - 这是一个表单数据对象，可以用来捕获html表单，同时很多方便的方法自己添加字段，如`formData.append(key,val)`，之后使用一些网络方法提交这些表单数据。
   - 本功能中使用它来像后台发送文件，发送包含文件的请求需要在请求头中设置`'Content-Type': 'multipart/form-data'`
   - flask中`request.files`是一个字典，保存了请求中所有文件名和文件内容形成的键值对，可以用来保存文件到后台

## 移动端

```
响应式布局：通过使用CSS media queries和流式布局等技术，使网站能够在多种尺寸的设备上得到最佳呈现。

触摸事件：移动端常用的触摸事件，例如单击、双击、滑动、拖放等。

移动端API：包括Geolocation API，Accelerometer API，Camera API等，提供了与移动设备硬件和操作系统交互的方法。

移动端离线存储：通过使用HTML5的离线存储和缓存API，使移动应用程序在没有网络连接的情况下仍然可以运行。

动画：使用CSS3或JavaScript实现的动画效果，提高交互体验。

移动端网络优化：通过使用压缩图像、使用CDN等方法，提高移动端网络加载速度。

混合开发：使用React Native，Ionic等技术，在移动端开发混合应用程序。
```



### 响应式布局

- 媒介查询：根据一些设备特征（屏幕尺寸，屏幕方向，分辨率）来选择某些css规则在该情况下生效，以此来保证在不同设备上页面的美观性正确性。一般配合max-width这样的属性来限定元素的范围。
- element-plus中的栅格布局本身就是响应式的，在设计的时候应当充分考虑这一点
- 字体的响应式布局，可以通过设定相对单位rem，之后通过媒体查询改变根元素的大小

### 常用事件

移动端常用的触摸事件，例如单击、双击、滑动、拖放等。

### 微信小程序

微信小程序是腾讯公司推出的一种基于微信平台的应用开发技术。它允许开发者在微信内快速开发自己的应用程序，而不需要下载和安装，可以直接使用。微信小程序是一种全新的开发方式，它可以实现基于微信内的移动应用开发，同时保证了应用的体验和功能。微信小程序支持使用JavaScript、HTML和CSS进行开发，具有高效快速、体验好、简单易用等特点。

## 补充

### 服务器端渲染（SSR）

基于nodejs serve服务环境进行渲染，所有的html代码在服务器端渲染。

优点：首屏加载速度快，利于seo

### ES6数组api

- splice(startIndex,deleteCount,新增内容)。号称数组处理的瑞士军刀，非常好用。