## js-原理

### 原型链

自顶向下

1. 顶层对象：js中设计了Object.prototype和它的构造函数Object
   - 对象原型没有进一步的源头了，所以`Object.prototype.__proto__==null`
   - 对象构造器是一个构造器对象，所以`Object.__proto__==Function.prototype`
2. 顶层构造器：js中设计了Function.prototype和它的构造函数Function
   - 由于它本身也是对象，`Function.prototype.__proto__==Object.prototype`
   - 函数构造器是一个构造器对象，所以`Function.__proto__==Function.prototype`

3. 普通对象：每个对象都有`__proto__`属性（原型链属性，js中的非标准属性，可以使用Object.getPrototypeOf获得），它指向对象的原型对象，也可以理解为是对象的构造函数的prototype所指向的对象。
4. 构造器：构造器不仅有`__proto__`属性，同时也有`prototype`属性，前者指向构造器作为一个对象本身，这个对象的原型，后者指向构造器构造出来的对象的原型对象。
5. 对象原型：对象原型包含了对象可以使用的属性和方法。

## Vue-basic

### Vue渐进式

允许开发者按照项目开发的需求，将所需要的功能逐步引入到项目中，实现定制化的开发

### single page application

含义：SPA是一种构建web应用的方式，它只有一个页面和一些必要的静态资源，其他的内容都是通过js动态生成的。

例子：SPA 通过路由机制，将页面的不同部分（视图）映射到不同的组件，实现了在同一个 HTML 页面内动态地加载不同的组件，从而达到切换页面的效果。

优点：用户体验好，局部刷新方便更快交互；缺点：不利于seo

### MVVM & MVC

1. mvc

   model和程序中数据相关的业务逻辑，

   view做页面上数据的展示，

   controller做程序的流程控制（处理输入，操作数据，调用视图）

2. mvvm

   view-model：实现了视图和数据的双向绑定，操作任意一方都可以同步变化

   优势：精简代码，不用频繁操作dom，让开发者把注意力都放在对于数据的操作上

   vue中的view和model之间还可以通过ref进行通信，不是标准的mvvm

## Vue2

### data函数

因为每个组件都可能多次被调用，而每次调用前都会再执行一次data函数，获得数据的初始化状态，以防数据污染。

### vue修饰符

| 修饰符              | 作用 |
| ------------------- | ---- |
| lazy                |      |
| trim                |      |
| number              |      |
| stop                |      |
| capture             |      |
| self                |      |
| once                |      |
| prevent             | -    |
| native              | -    |
| left、right、middle |      |
| passive             |      |
| camel               | -    |
| sync                | -    |
| keyCode             |      |

## Vue3

### vue3的响应式变量应用

1. 为什么要使用reactive函数？

   vue3项目中，onMounted之后就完成了页面dom的渲染，此时再去修改组件的某些值也无法实现在页面上的重新渲染。

   当我们需要页面随着数据的改变而重新进行局部的渲染，则需要吧这些数据声明为响应式的

2. reactive的原理简单理解？

   Reactive 实现的原理是通过 Object.defineProperty 在对象属性 getter 和 setter 方法上==添加依赖追踪==，通过闭包来==捕获并管理依赖关系==。当对象中某个属性的值发生变化时，setter 会==通知观察者并触发重新渲染==。

   观察者模式：观察者模式是一种设计模式，它定义了对象之间的一对多关系，当一个对象改变状态时，他的所有依赖都将收到通知并自动更新。主体和观察者之间形成了一种松耦合的关系，因此观察者可以动态地注册和注销，而不会影响到主体的其他部分。

3. reactive和ref

   - ref: ref 是一个响应式的单个值，它可以通过 .value 属性读写数据。
   - reactive: reactive 是一个响应式对象，它可以包含多个值，通过读写对象属性来读写数据。

### vue3的单向数据流

1. 循环更新

   循环更新发生在两个组件之间，当一个组件中的响应式对象改变时，会更新另一个组件中使用的响应式对象，而该对象又会更新第一个响应式对象，以此类推。这样会形成一个更新的无限循环，可能导致意料之外的行为，例如错误，崩溃或无限渲染。

2. 单向数据流原则：为了避免 Vue3 中的循环更新，你应该遵循单向数据流原则，也就是数据只从父组件向子组件流动，不会反过来。这意味着子组件不应该修改来自父组件的 prop，而是应该通过事件或者回调将数据传回父组件。


### onMounted+事件监听

知识点：vue3中的事件监听，图表resize

1. 对于`onMounted`的理解

   - 组件挂载：Vue3中的组件挂载指的是将组件与页面中的 DOM 元素对应起来的过程。在 Vue 中，每个组件都有一个对应的虚拟 DOM，而挂载的过程即是将组件的虚拟 DOM 映射到真实的 DOM 上。在组件挂载完成后，组件可以对页面中的 DOM 元素进行操作，并对用户的交互产生反应。
   - 虚拟dom->真实dom： 组件的信息在编译过程中被转换为真实的 DOM。Vue 在挂载组件时，会先将组件的虚拟 DOM 编译为 JavaScript 代码，再执行该代码以生成真实的 DOM。编译过程中，Vue 会考虑组件的模板、数据、事件等信息，并将其映射到真实的 DOM 元素上。这样，组件的信息就可以通过真实的 DOM 展示到页面上，并对用户交互做出反应。
   - onMounted时间点：Vue 的 `onMounted` 钩子函数在组件被挂载完成之后执行。也就是说，组件的虚拟 DOM 已经被编译为真实的 DOM，并与页面上的 DOM 元素对应起来，组件已经可以对页面上的元素进行操作。`onMounted` 钩子函数可以让我们在组件挂载完成后执行一些操作，==比如请求数据、初始化组件状态等==。

   通过以上的内容，可知可在onMounted中对页面上已经存在的图表dom进行操作，也就是在这里对`resize`事件进行一个监听

2. 对`unMounted`的理解

   - 当组件被卸载时，Vue 将会调用 `unmounted` 钩子函数。在该阶段，组件的实例已经不再被需要，并且已经从页面中删除了。==在该阶段，可以执行一些清理操作，如移除事件监听器，清除定时器等，以保证不会对其他组件造成影响==。

   也就是在这个页面组件上由开发者添加的任何监听器，定时器等统一在此处清理。

3. 对事件清理的理解

   当某个组件被卸载时，在它上面安装的监听器也应该被移除，否则当大量的监听器都没能及时清除的时候可能会导致内存的泄漏

## webpack

```
webpack 的基础概念：模块打包、入口、出口等。

webpack 的配置：通过 webpack.config.js 配置打包参数。

webpack 加载器和插件：使用加载器对不同类型的文件进行转换和处理，使用插件增强打包的功能。

webpack 编译和优化：使用 source map 和 tree shaking 等技术，提高代码的可调试性和性能。

webpack 的实际应用场景：如多页面应用、懒加载等。
```

## nodejs

### 基础概念

1. 服务器：处理用户的各类请求并且响应用户

2. nodejs：一个开源和跨平台的JavaScript运行时环境，js通过nodejs可以连接服务器，访问本地文件等，使js可以运行在服务器。

3. node的非阻塞范式，处理高并发

   - nodejs的单线程指的是当函数调用栈中有函数在运行，js是不能处理其他请求的
   - 当在node中创建一个服务器，node会开辟一个线程来处理请求，同时初始化一个调用栈
   - 异步模块：一个任务中的同步操作在调用栈中很快地被执行了，任务中的异步操作则进入异步模块来执行。异步模块是多线程的。当执行结束后有回调函数，则把回调函数放入对应的任务队列，以此来进行事件循环。
   - 事件循环：node中有多个任务队列（timer、poll、check），异步模块也有任务队列（nextTick、micro）。当调用栈为空时（调用栈同步任务完成），会检查这些队列中是否有任务，并且按照一定的顺序将这些队列中的任务逐一执行。这一整个过程叫做事件循环。

4. 异步编程+流程控制

   - 原因：由于node中的非阻塞范式，执行异步操作的时间不同，导致回调函数进入任务队列和最终执行的顺序难以确定，因此根据业务的需要，要做出符合要求的流程控制。

   - 解决方案

     | 流程要求 | 回调函数     | promise          | async、await                           |
     | -------- | ------------ | ---------------- | -------------------------------------- |
     | 顺序执行 | 回调函数嵌套 | `.then`链式调用  | 语法糖：使用同步的书写格式来写异步代码 |
     | 同步执行 | 中间变量控制 | `Promise.all`Api | 同promise                              |

5. 模块、包：

   5.1 CommonJs

   - 模块：一份独立的js文件对应一个自己的module对象，通过`exports`导入，提供一些函数、对象、变量的js文件，有自己的作用域，同时可以通过`require`导出
   - `require()`:
     - 核心模块：随node一起安装，模块名
     - 第三方模块：npm安装，安装在`node_moudles`，模块名
     - 自己写的模块：路径

   5.2 ESmodule

   - 使用export，import导出导入，配置`package-json`中`"type": "module"`

   5.3 区别（待补充）

   CommonJs在运行时加载模块，ESmodule在编译时加载模块

6. npm（Node Package Manager）：用于管理nodejs应用程序所需的模块和模块之间的依赖关系

   - 包：包是一个可以安装到 Node.js 应用程序中的软件包，它可以包含一个或多个模块，以及其他必要的资源。包可以通过 `npm` 进行管理，并且可以在多个应用程序间共享。
   - package.json：用于定义包，该文件包含了包的元数据，如：name、description、version、license、author、dependencies等

7. 事件驱动程序

   - EventEmitter：EventEmitter类用来实现node中的事件驱动，核心就是事件触发`new EventEmitter().emit(event)`与添加事件监听器功能`new EventEmitter().addEventListener(event,handler)`的封装。
   - node中支持事件响应的模块是的`EventEmitter`子类，如http 、fs等

8. Buffer：Buffer 类在 Node.js 中主要用于处理二进制数据。可以将图片文件等二进制内容读入缓冲区，并进行操作，例如读取、写入、转换编码格式等。主要的原因在于js只有处理字符串的api，难以处理以二进制形式存储的网络请求、图片、文件等。

9. Stream模块

   - 目的：就是为了处理端到端的数据交换

   - I/O操作：网络请求、文件读取等
   - 流模式：发送方->缓冲区->接收方，流模式是将大量数据分割成小块，逐块地处理并传输，这样可以保证数据的流畅接收。在 Node.js 中，stream 模块提供了一种实现流模式的方法。通过流模式，我们可以避免将整个文件一次性读入内存，从而降低内存压力，提高程序效率。
   - Stream：提供流接口的api，提供了各种流的实现，如可读流，可写流和双工流。它们都是基于EventEmitter的，所以它们可以绑定事件以监听数据的流动。

10. nodejs在项目中的应用

    1. 服务器端渲染：在服务器运行js并且请求后端数据，将最终渲染好的页面发送给浏览器运行
    2. 写后台：使用nodejs编写后端逻辑，给前端提供访问数据的接口
    3. 提供npm包管理器：可以方便地安装和管理 Vue 相关的开发工具和第三方库。

## 计网基础

###    跨源请求

   1. 基础概念

      - 源（origin）：域（domain）/端口（port）/协议（protocol）的组合。
      - 域名（Domain Name）：是一个字符串，代表一个网络上的计算机的地址。它是对于网络中使用数字地址（如IP地址）的一个抽象层次。域名是用来替代数字地址，以方便用户记忆和识别。
      - IP地址：计算机在 Internet 中的唯一标识。
      - DNS：DNS (Domain Name System) 是一个基于分布式数据库的系统，它把 Internet 上每个主机名和 IP 地址进行了映射，使得人们可以通过主机名访问网站，而不需要记住每个网站的 IP 地址。
      - 安全跨源请求流程：浏览器发送请求，请求中包含origin->服务器确定origin是被允许的源，服务器发送包含`Access-Control-Allow-Origin`响应->浏览器拿到服务器发送的结果

   2. 开发环境下的跨源请求

      可以把vue和flask项目看作服务器，他们的主机ip+端口号可以确定一个网络服务器的地址，但是它不是一个独特的域名。这两个项目之间的通信也需要设置跨源请求，但是不需要指定源。

        知识点3：`FormData`对象

         - 这是一个表单数据对象，可以用来捕获html表单，同时很多方便的方法自己添加字段，如`formData.append(key,val)`，之后使用一些网络方法提交这些表单数据。
         - 本功能中使用它来像后台发送文件，发送包含文件的请求需要在请求头中设置`'Content-Type': 'multipart/form-data'`
         - flask中`request.files`是一个字典，保存了请求中所有文件名和文件内容形成的键值对，可以用来保存文件到后台

### `FormData`对象

   - 这是一个表单数据对象，可以用来捕获html表单，同时很多方便的方法自己添加字段，如`formData.append(key,val)`，之后使用一些网络方法提交这些表单数据。
   - 本功能中使用它来像后台发送文件，发送包含文件的请求需要在请求头中设置`'Content-Type': 'multipart/form-data'`
   - flask中`request.files`是一个字典，保存了请求中所有文件名和文件内容形成的键值对，可以用来保存文件到后台

## 移动端

```
响应式布局：通过使用CSS media queries和流式布局等技术，使网站能够在多种尺寸的设备上得到最佳呈现。

触摸事件：移动端常用的触摸事件，例如单击、双击、滑动、拖放等。

移动端API：包括Geolocation API，Accelerometer API，Camera API等，提供了与移动设备硬件和操作系统交互的方法。

移动端离线存储：通过使用HTML5的离线存储和缓存API，使移动应用程序在没有网络连接的情况下仍然可以运行。

动画：使用CSS3或JavaScript实现的动画效果，提高交互体验。

移动端网络优化：通过使用压缩图像、使用CDN等方法，提高移动端网络加载速度。

混合开发：使用React Native，Ionic等技术，在移动端开发混合应用程序。
```



### 响应式布局

- 媒介查询：根据一些设备特征（屏幕尺寸，屏幕方向，分辨率）来选择某些css规则在该情况下生效，以此来保证在不同设备上页面的美观性正确性。一般配合max-width这样的属性来限定元素的范围。
- element-plus中的栅格布局本身就是响应式的，在设计的时候应当充分考虑这一点
- 字体的响应式布局，可以通过设定相对单位rem，之后通过媒体查询改变根元素的大小

### 常用事件

移动端常用的触摸事件，例如单击、双击、滑动、拖放等。

### 微信小程序

微信小程序是腾讯公司推出的一种基于微信平台的应用开发技术。它允许开发者在微信内快速开发自己的应用程序，而不需要下载和安装，可以直接使用。微信小程序是一种全新的开发方式，它可以实现基于微信内的移动应用开发，同时保证了应用的体验和功能。微信小程序支持使用JavaScript、HTML和CSS进行开发，具有高效快速、体验好、简单易用等特点。