### 01-deepClone
1. 基本思路：分类讨论+递归
- 如果是基本类型直接返回值，是对象则需要为每一个属性开辟新的空间
- 而对于每一个属性（包括嵌套的属性）都需要判断类型，所以使用递归
2. 循环引用问题
- 自己引用自己的对象会使得递归变为死循环，而实际上引用自己只需要开辟一份存储空间并且保存该空间地址，因此对于每个对象复制前都判断它是否之前复制过，如果被复制过直接指向之前的这个空间即可。使用map实现。

### 04-防抖

学习博客：

https://github.com/mqyqingfeng/Blog/issues/22

1. 基本目标和实现：

   - 在 n 时间内，某个事件只触发1次
   - 通过封装原本处理程序，在封装函数内设置一个定时器，并且返回新的处理程序，设定为清除之前的定时器，在n时间后触发原本的处理程序

2. this

   在事件处理程序中，this必须指向事件对象（某个页面上的dom元素），而当使用了debounce封装事件处理程序，其中原本的处理程序（getUserAction）this不指向事件对象，而是指向了window，导致了问题。因此需要借助bind指定this的指向

3. event

   事件处理程序（事件发生后的回调函数）有event事件对象作为参数。而当debounce封装了事件处理程序之后，新处理程序的参数（包含event对象）没有传递给原本的处理程序（getUserAction），导致原本处理程序中对于event的使用失效，所以要把arguments对象传递一下

---

按照以上实现思路，我们得出结论，只有当事件停止触发的n时间之后，这个事件的处理程序才会被调用，所以需要设定新目标

4. 立即执行：
   - 立刻执行函数，然后等到停止触发 n 时间后，才可以重新触发执行。
   - 给封装函数再增设一个参数immediate，如果设置为立即执行模式（immediate==true）。执行以下算法：
     1. 若定时器为初始状态`timer=null`，事件被触发，立即调用处理程序。同时通过定时器设定在n时间后重置定时器`timer=null`。
     2. 若在n时间内（此时`timer!==null`），事件再次被触发，取消上一个计时器，设定新的定时，在此刻开始的n时间后重置定时器`timer=null`。
   
5. 返回值

   如果原处理程序有返回值，那么就传递一下

6. 取消按钮

   根据立即执行的设计思路，如果等待timer被重置需要等到最后一次操作经过n时间，所以给防抖封装增加一个方法，直接将timer赋值为null，调用它后处理程序在事件发生后立即被调用。

### 05-节流

学习博客：https://github.com/mqyqingfeng/Blog/issues/26

1. 时间戳

   记录上一次触发的时间戳和下一次触发的时间戳，以此计算出时间差，根据时间差和n时间之间的比较，决定是否调用处理程序。保证在n时间内只调用一次处理程序。

   在装饰器中需要保存记录上一次时间戳的变量。

   特点：立即执行

2. 定时器

   若定时器为null，设定新的定时器在n时间后处理程序调用，并且将定时器重置为null

   特点：需要等待n时间才会触发

3. 新思路

   事件触发后...

   1. 计算剩余时间remainings，如果remainings<=0，那么可以使用处理程序了，同时需要记录previous和重置定时器
   2. 如果n时间内不存在定时器，同时剩余时间还有，那么我们设定一个定时器，在remaings时间后，我们调用程序同时记录previous和重置定时器

4. 头尾问题（待学习）

   在上述设定中，在n时间内触发事件，开始时会调用处理程序，remaings时间后也会调用处理程序，因此设计leading和tailing两个属性来控制调用处理程序的时机

   