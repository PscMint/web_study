### 01-deepClone
1. 基本思路：分类讨论+递归
- 如果是基本类型直接返回值，是对象则需要为每一个属性开辟新的空间
- 而对于每一个属性（包括嵌套的属性）都需要判断类型，所以使用递归
2. 循环引用问题
- 自己引用自己的对象会使得递归变为死循环，而实际上引用自己只需要开辟一份存储空间并且保存该空间地址，因此对于每个对象复制前都判断它是否之前复制过，如果被复制过直接指向之前的这个空间即可。使用map实现。

### 04-防抖

学习来源：

https://github.com/mqyqingfeng/Blog/issues/22

1. 基本目标和实现：

   - 在 n 时间内，某个事件只触发1次
   - 通过封装原本处理程序，在封装函数内设置一个定时器，并且返回新的处理程序，设定为清除之前的定时器，在n时间后触发原本的处理程序

2. this

   在事件处理程序中，this必须指向事件对象（某个页面上的dom元素），而当使用了debounce封装事件处理程序，其中原本的处理程序（getUserAction）this不指向事件对象，而是指向了window，导致了问题。因此需要借助bind指定this的指向

3. event

   事件处理程序（事件发生后的回调函数）有event事件对象作为参数。而当debounce封装了事件处理程序之后，新处理程序的参数（包含event对象）没有传递给原本的处理程序（getUserAction），导致原本处理程序中对于event的使用失效，所以要把arguments对象传递一下

---

按照以上实现思路，我们得出结论，只有当事件停止触发的n时间之后，这个事件的处理程序才会被调用，所以需要设定新目标

4. 立即执行：
   - 立刻执行函数，然后等到停止触发 n 时间后，才可以重新触发执行。
   - 给封装函数再增设一个参数immediate，如果设置为立即执行模式（immediate==true）。执行以下算法：
     1. 若定时器为初始状态`timer=null`，事件被触发，立即调用处理程序。同时通过定时器设定在n时间后重置定时器`timer=null`。
     2. 若在n时间内（此时`timer!==null`），事件再次被触发，取消上一个计时器，设定新的定时，在此刻开始的n时间后重置定时器`timer=null`。
   
5. 返回值

   如果原处理程序有返回值，那么就传递一下

6. 取消按钮

   根据立即执行的设计思路，如果等待timer被重置需要等到最后一次操作经过n时间，所以给防抖封装增加一个方法，直接将timer赋值为null，调用它后处理程序在事件发生后立即被调用。

### 05-节流

学习来源：https://github.com/mqyqingfeng/Blog/issues/26

1. 时间戳

   记录上一次触发的时间戳和下一次触发的时间戳，以此计算出时间差，根据时间差和n时间之间的比较，决定是否调用处理程序。保证在n时间内只调用一次处理程序。

   在装饰器中需要保存记录上一次时间戳的变量。

   特点：立即执行

2. 定时器

   若定时器为null，设定新的定时器在n时间后处理程序调用，并且将定时器重置为null

   特点：需要等待n时间才会触发

3. 新思路

   事件触发后...

   1. 计算剩余时间remainings，如果remainings<=0，那么可以使用处理程序了，同时需要记录previous和重置定时器
   2. 如果n时间内不存在定时器，同时剩余时间还有，那么我们设定一个定时器，在remaings时间后，我们调用程序同时记录previous和重置定时器

4. 头尾问题（待学习）

   在上述设定中，在n时间内触发事件，开始时会调用处理程序，remaings时间后也会调用处理程序，因此设计leading和tailing两个属性来控制调用处理程序的时机


### 06-instanceof的实现

需要用到原型链的基础知识，概括如下：

自顶向下来看：

1. 顶层对象：js中设计了Object.prototype和它的构造函数Object
   - 对象原型没有进一步的源头了，所以`Object.prototype.__proto__==null`
   - 对象构造器是一个构造器对象，所以`Object.__proto__==Function.prototype`
2. 顶层构造器：js中设计了Function.prototype和它的构造函数Function
   - 由于构造器原型本身也是对象，`Function.prototype.__proto__==Object.prototype`
   - 函数构造器是一个构造器对象，所以`Function.__proto__==Function.prototype`

3. 普通对象：每个对象都有`__proto__`属性（原型链属性，js中的非标准属性，可以使用Object.getPrototypeOf获得），它指向对象的原型对象，也可以理解为是对象的构造函数的prototype所指向的对象。
4. 构造器：构造器不仅有`__proto__`属性，同时也有`prototype`属性，前者指向构造器作为一个对象本身，这个对象的原型，后者指向构造器构造出来的对象的原型对象。
5. 对象原型：对象原型包含了对象可以使用的属性和方法。

### 07-数组扁平化

学习来源：[JavaScript专题之数组扁平化 · Issue #36 · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/issues/36)

1. 数组扁平化的本质是通过递归

2. 为了让扁平化函数能够为其他的工具函数更好地提供扁平化功能，

   设置了strict属性，可以在扁平化的过程中去除那些非数组的元素

   设置了shallow属性，可以只扁平化一层，而不进行递归

3. 应用场景，比如让`[1,2,[3,4,5],[6,5,7]]`转化为`[3,4,5,6,5,7]`就可以设置strict=true，shallow=true
### 08-reduce的实现
实际上Array的函数，接收处理函数的回调函数，回调函数就像一套处理程序，给数组迭代的处理，最后返回想要的结果，其中很多中间量是保存在Array函数中的

### 09-去重

去重是指从一个集合中删除重复的元素，以便只保留独特的元素。集合可以是数组、对象、字符串等。

本例中主要实现了三种去除数组中重复元素的方法。