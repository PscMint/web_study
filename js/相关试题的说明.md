### 01-deepClone
1. 基本思路：分类讨论+递归
- 如果是基本类型直接返回值，是对象则需要为每一个属性开辟新的空间
- 而对于每一个属性（包括嵌套的属性）都需要判断类型，所以使用递归
2. 循环引用问题
- 自己引用自己的对象会使得递归变为死循环，而实际上引用自己只需要开辟一份存储空间并且保存该空间地址，因此对于每个对象复制前都判断它是否之前复制过，如果被复制过直接指向之前的这个空间即可。使用map实现。

### 04-防抖

学习博客：

https://github.com/mqyqingfeng/Blog/issues/22

1. 基本目标和实现：

   - 在 n 时间内，某个事件只触发1次
   - 通过封装原本处理程序，在封装函数内设置一个定时器，并且返回新的处理程序，设定为清除之前的定时器，在n时间后触发原本的处理程序

2. this

   在事件处理程序中，this必须指向事件对象（某个页面上的dom元素），而当使用了debounce封装事件处理程序，其中原本的处理程序（getUserAction）this不指向事件对象，而是指向了window，导致了问题。因此需要借助bind指定this的指向

3. event

   事件处理程序（事件发生后的回调函数）有event事件对象作为参数。而当debounce封装了事件处理程序之后，新处理程序的参数（包含event对象）没有传递给原本的处理程序（getUserAction），导致原本处理程序中对于event的使用失效，所以要把arguments对象传递一下

---

按照以上实现思路，我们得出结论，只有当事件停止触发的n时间之后，这个事件的处理程序才会被调用，所以需要设定新目标

4. 立即执行：
   - 立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。
   - 给封装函数再增设一个参数immediate，如果设置为立即执行模式（immediate==true），则立即执行函数，而不设定计时器，但是在限定的时间内只能立即执行一次

5. 返回值

   如果原处理程序有返回值，那么就传递一下

6. 取消按钮

   根据立即执行的设计思路，如果等待timer被重置需要等到最后一次操作经过n时间，所以给防抖封装增加一个方法，直接将timer赋值为null，调用它后处理程序在事件发生后立即被调用。