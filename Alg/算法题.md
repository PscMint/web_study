# 算法学习心得

## 刷题清单

[代码随想录 (programmercarl.com)](https://www.programmercarl.com/)

[vortesnail/leetcode: Javascript solutions to problems on LeetCode (github.com)](https://github.com/vortesnail/leetcode)

## 回溯

### 对于回溯的本质理解

回溯算法是将所有可能的情况通过树形结构排列出来，从中选择符合要求的结果进行收集。而回溯是这个过程的关键一步，它可以返回到上一次选择的中间位置，选择其他可能的元素，从而实现对所有可能结果的遍历。

### 对于实现的理解

```
let path =[]
let res
function tracingBack(){
	if(终止条件满足)
		//收集结果
		res.push(path)
		return
	for(横向遍历)
		//收集元素
		path.push(节点信息)
		tracingBack()//递归
		//回溯
		path.pop()
		
}
```

### 对于具体问题的理解

- 组合问题

  组合问题往往给出一个集合，要在集合中选取子元素构成一个新的集合，形成的这个新集合需要满足题目的要求。

  组合问题中的去重问题

  引发去重问题的根本原因：在组合问题中，是不需要考虑选取的元素之间的位置关系的。举例来说，[2,4,4]等同于[4,2,4]，而如果以2开头或者以4开头来检索，不去重的话很显然会收集到重复的结果。

  【一个集合，无重复元素】

  而当我们选择了第一个元素A之后，包含该元素A的所有可能的组合都会在以它为起点的深度遍历的过程中搜索到，也就意味着在横向遍历A后面的元素时，后面元素在纵向遍历的过程中，不再考虑元素A。

  【一个集合，有重复元素】

  如果集合中有重复的元素，那它们本质上是等价的，只需要以其中之一为起点向下深度遍历结果分支，而在之后的横向遍历中如果遇到了重复的元素直接跳过即可。在技术实现层面，可以使用used数组或者set集合来去重。

- 分割问题

  分割问题一般来说是给出原始的字符串，按照题目的需求对字符串进行分隔，返回符合需要的分割方案。

  可以将分割出来的子串看作是一个被选择的元素，如果它是合法的，那么在它的基础上深度遍历后续的合法子串，反之，如果它是非法的，则进行剪枝，继续横向遍历下一个子串。

- 子集问题

  求解出集合的所有子集

  子集问题的思路可以与组合问题的思路相互对照。同时子集问题也要去重，思路也是延续前者，避免同一个元素的反复组合。

  |          | 组合                         | 子集                         |
  | -------- | ---------------------------- | ---------------------------- |
  | 收集条件 | 路径上节点的组合情况满足题意 | 每经过一个节点所形成的新路径 |

- 排列问题

  将给出的集合进行全排列

​	【集合中没有重复元素】

​	相对来说比较简单，使用used数组记录已经被选择的元素，在它后面的深度遍历过程中，避免选择那些路	径上已经使用过的元素即可

​	【集合中有重复元素】

​	关键在于横向的元素是等价的，所以不能重复选择。而纵向的元素必须全部选择完，而不在乎是否出现元素重复（也可以说在纵向上所有元素都是独特的，不存在等价），只是避免选择本条路径已经选择的元素即可。



